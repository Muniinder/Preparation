Day:1     3.1.2019        
Review : 1.6, 1.3
Total Done : 1.(1,2,3,4,5,6,7)
Work : {
          def removeDuplicates(s):                            ------------------------------3------------------------------------
            length_of_string = len(s)
            if length_of_string == 0:
                    return 'Empty String'
            elif length_of_string == 1:
                    return s
            elif length_of_string > 1:
                for k,word in enumerate(s):
                    var1 = k+1
                    for w in s[k+1:]:
                        if w == word:
                            s = s[0 : var1] + s[ var1+1 : ]
                        var1 += 1
                return s
        def checkAnagram(s1,s2):                              ------------------------------4------------------------------------
            length_of_string1 = len(s1)
            length_of_string2 = len(s2)
            if length_of_string1 == 0 or length_of_string2 == 0:
                return "length of String is Zero"
            elif length_of_string1 == length_of_string2:
                arr1 = [0]*255
                arr2 = [0]*255
                for w in s1:
                    val = ord(w)
                    arr1[val] += 1
                for w in s2:
                    val = ord(w)
                    arr2[val] += 1
                if arr1 == arr2:
                    return "Anagrams"
                else:
                    return "Not Anagrams"
            else:
                return "Lenghts of strings are not same"

        def rotateArray(arr1):                      ------------------------------6------------------------------------

            print("Before Rotation")
            print_2d_array(arr1)
            l1 = len(arr1)
            for i in range(0,l1):
                for j in range(i,l1):
                    if i == j:
                        continue
                    arr1[i][j] , arr1[j][i] = arr1[j][i] , arr1[i][j]
            print("After Rotation")
            print_2d_array(arr1)

        def print_2d_array(arr1):
            for a1 in arr1:
                for a2 in a1:
                    print(a2,"  ",end="")
                print("\n",end="")

        def entire_row_col_zero(arr1):                    ------------------------------7--------------------------------------
              l1 = len(arr1)
              l2 = len(arr1[0])
              c_col = []
              for i in range(0,l1):
                  for j in range(0,l2):
                      if arr1[i][j] == 0:
                          c_col.append([i,j])
              for i in c_col:
                  for a in range(0,l1):
                      a1 = i[1]
                      arr1[a][a1] = 0
                  for b in range(0,l2):
                      b1 = i[0]
                      arr1[b1][b] = 0
          def print_2d_array(arr1):
                  for a1 in arr1:
                      for a2 in a1:
                          print(a2,"  ",end="")
                      print("\n",end="")
   }
Day:2     4.1.2019        
Review : 
Total Done : 1.(8)
Work : {
          def is_substring(s1,s2):                ------------------------------8------------------------------------
              if s1.find(s2) == -1:
                  return 0
              else:
                  return 1
          def isRotation(s1,s2):
              if len(s1) == len(s2):
                  s2 = s2 + s2
                  if s2.find(s1) == -1:
                     return 0
                  else:
                      return 1
              else:
                  return 0
}
Day:3     5.1.2019
Day:4     6.1.2019
Day:5     7.1.2019
Day:6     8.1.2019
Review:
Total Done : 
Work : {
          class Node:
    def __init__(self,data,min_val):
        self.__data = data
        self.__min_val = min_val
    def get_data(self):
        return self.__data
    def get_min_val(self):
        return self.__min_val
class Stack:
    def __init__(self,max_size):
        self.__max_size = max_size
        self.__elements = [None]*max_size
        self.__top = -1
        self.__min_ele = None
    def is_empty(self):
        if self.__top == -1:
            return 1
        return 0
    def push(self,data):
        if self.__top == -1:
            self.__min_ele = data
        else:
            if self.__min_ele > data:
                self.__min_ele = data
        self.__top += 1
        self.__elements[self.__top] = Node(data,self.__min_ele)
        
    def pop(self):                                              # will return the address
        if self.is_empty():
            print("Stack is empty")
        else:
            data = self.__elements[self.__top]
            self.__top -= 1
            return data
    def is_full(self):
        if self.__top == (self.__max_size - 1):
            return 1
        return 0
    def get_max_size(self):
        return self.__max_size
        
    def get_min(self):
        min_ele = self.pop()
        data = min_ele.get_data()
        self.push(data)
        return min_ele.get_min_val()
        
    def __str__(self):
        msg = []
        index = self.__top
        while index >= 0:
            msg.append(str( self.__elements[index].get_data() ))
            index -= 1
        msg = " ".join(msg)
        msg = "Stack from top to bottom : " + msg
        return msg
-------------------------------------SET OF STACKS IN A STACK WHEN IT REACHES A THRESHHOLD VALUE-------------------------------------
class Stack:
    def __init__(self,max_size):
        self.__max_size=max_size
        self.__elements=[None]*self.__max_size
        self.__top=-1

    def is_full(self):
        if(self.__top==self.__max_size-1):
            return True
        return False

    def is_empty(self):
        if(self.__top==-1):
            return True
        return False

    def push(self,data):
        if(self.is_full()):
            print("The stack is full!!")
        else:
            self.__top+=1
            self.__elements[self.__top]=data

    def pop(self):
        if(self.is_empty()):
            print("The stack is empty!!")
        else:
            data= self.__elements[self.__top]
            self.__top-=1
            return data

    def display(self):
        if(self.is_empty()):
            print("The stack is empty")
        else:
            index=self.__top
            while(index>=0):
                print(self.__elements[index])
                index-=1

    def get_max_size(self):
        return self.__max_size

    #You can use the below __str__() to print the elements of the DS object while debugging
    def __str__(self):
        msg=[]
        index=self.__top
        while(index>=0):
            msg.append((str)(self.__elements[index]))
            index-=1
        msg=" ".join(msg)
        msg = " " + msg
        return msg
        
class set_of_stack:
    def __init__(self,max_size):
        self.__max_size = max_size
        self.__elements = [Stack(max_size)]
        self.__top = -1
    def is_empty(self):
        for s in self.__elements:
            if not s.is_empty():
                return 0
        return 1
    def is_full(self):
        if self.__top == self.__max_size - 1:
            return True
        return False
        #for s in self.__elements:
         #   if not s.is_full():
         #       return False
        return True
    def push(self,data):
        if self.__top == -1:
            self.__top += 1
        if self.is_full():
            if self.__elements[self.__top].is_full():
                print("SetStack is full")
            else:
                if self.__elements[self.__top].is_full():
                    self.__top += 1
                    temp = Stack(self.__max_size)
                    self.__elements.append(temp)
                    self.__elements[self.__top].push(data)
                else:
                    self.__elements[self.__top].push(data)
        else:
            if self.__elements[self.__top].is_full():
                self.__top += 1
                temp = Stack(self.__max_size)
                self.__elements.append(temp)
                self.__elements[self.__top].push(data)
            else:
                self.__elements[self.__top].push(data)
    def pop(self):
        if self.is_empty():
            print("SetStack is empty")
        else:
            if self.__elements[self.__top].is_empty():
                self.__top -= 1
                return self.__elements[self.__top].pop()
            else:
                return self.__elements[self.__top].pop()
    def print_set_of_stack(self):
        if self.__top == -1:
            print("Set of Stack is Empty")
        else:
            index = self.__top
            print("\nTop to Bottom :", end= "")
            while index >= 0:
                print(self.__elements[index],end = "")
                index -= 1

s1 = set_of_stack(5)

s1.push(25)
s1.push(24)
s1.push(23)
s1.push(22)
s1.push(21)
s1.push(20)
s1.push(19)
s1.push(18)
s1.push(17)
s1.push(16)
s1.push(15)
s1.push(14)
s1.push(13)
s1.push(12)
s1.push(11)
s1.push(10)
s1.push(9)
s1.push(8)
s1.push(7)
s1.push(6)
s1.push(5)
s1.push(4)
s1.push(3)
s1.push(2)
s1.push(1)
s1.print_set_of_stack()

}

Day:7     9.1.2019
Review: Tower of hanoi, sort_with_stack
Total Done: Stacks almost complete
Work:{
          def sort_wc(s):
              r = Stack(10)
              while not s.is_empty():
                  temp = s.pop()
                  while not r.is_empty() and r.peek() > temp:
                      s.push(r.pop())
                  r.push(temp)
              return r
}
Day:8,9,10,11,12,13,14
Work:     {         SUCCESSFULLY WASTED         }

Day:15:   15.1.2019
Review:
Total Done: 
Work:{
          def sp_sort(s1):
              s2 = Stack(6)
              s2.push(s1.pop())
              while not s1.is_empty():
                  data = s1.pop()
                  while not s2.is_empty() and s2.peek() > data:
                      s1.push(s2.pop())
                  s2.push(data)
 class Queue:
    def __init__(self,max_size):

        self.__max_size=max_size
        self.__elements=[None]*self.__max_size
        self.__rear=-1
        self.__front=0

    def is_full(self):
        if(self.__rear==self.__max_size-1):
                return True
        return False

    def is_empty(self):
        if(self.__front>self.__rear):
            return True
        return False

    def enqueue(self,data):
        if(self.is_full()):
            print("Queue is full!!!")
        else:
            self.__rear+=1
            self.__elements[self.__rear]=data

    def dequeue(self):
        if(self.is_empty()):
            print("Queue is empty!!!")
        else:
            data=self.__elements[self.__front]
            self.__front+=1
            return data

    def display(self):
        for index in range(self.__front, self.__rear+1):
            print(self.__elements[index])


    def get_max_size(self):
        return self.__max_size

    #You can use the below __str__() to print the elements of the DS object while debugging
    def __str__(self):
        msg=[]
        index=self.__front
        while(index<=self.__rear):
            msg.append((str)(self.__elements[index]))
            index+=1
        msg=" ".join(msg)
        msg="Queue data(Front to Rear): "+msg
        return msg
                  
 class Node:
    def __init__(self,key):
        self.left = None
        self.right = None
        self.key = key
    def get_left(self):
        return self.left
    def get_right(self):
        return self.right
    def get_key(self):
        return self.key
    def set_left(self,Node):
        self.left = Node
    def set_right(self,Node):
        self.right = Node

class BinaryTree:
    def __init__(self,root_key):
        self.__root = Node(root_key)
    def get_root(self):
        return self.__root
    def add_Node(self,val):
        node = self.__root
        while node:
            if node.get_left() is None:
                node.set_left(Node(val))
                break
            elif node.get_right() is None:
                node.set_right(Node(val))
                break
            node = node.get_left()

    #def del_a_Node(self,key):
        
    #def print_InOrder(self):
def InOrder(root):
    if root:
        InOrder(root.left)
        print(root.key,end=" ")
        InOrder(root.right)
def pre_order(root):
    if root:
        print(root.key,end=" ")
        pre_order(root.left)
        pre_order(root.right)
def post_order(root):
    if root:
        post_order(root.left)
        post_order(root.right)
        print(root.key,end=" ")
def Level_order(root):
    q1 = Queue(500)
    q1.enqueue(root)
    print(root.key,end=" ")
    while not q1.is_empty():
        data = q1.dequeue()
        if data.left is not None:
            q1.enqueue(data.left)
            print(data.left.key,end=" ")
        if data.right is not None:
            q1.enqueue(data.right)
            print(data.right.key,end=" ")
bt_1 = BinaryTree(1)
bt_1.add_Node(2)
bt_1.add_Node(3)
bt_1.add_Node(4)
bt_1.add_Node(5)
InOrder(bt_1.get_root())
print("\n")
pre_order(bt_1.get_root())
print("\n")
post_order(bt_1.get_root())
     
}

Day : 16,17,18,19,20
work: {wasted}
Day : 21
Work:{
          def height(root):
              if root is None:
                  return 0
              return max(height(root.left),height(root.right)) + 1
          def is_balanced(root):
              if root is None:
                  return True
              lh = height(root.left)
              rh = height(root.right)
              if abs(lh-rh) > 1:
                  return False
              return True
              
          from collections import defaultdict
          class graph:
              def __init__(self):
                  self.elements = defaultdict(list)
              def add_edge(self,source,destination):
                  self.elements[source].append(destination)
              def print_bfs(self,s):
                  queue = []
                  if s < len(self.elements) and s >= 0:
                      visited = [False]*len(self.elements)
                  else:
                      print("element is not there")
                      return 0
                  queue.append(s)
                  while queue:
                      data = queue.pop(0)
                      visited[data] = True
                      print(data,end=" ")
                      for i in self.elements[data]:
                          if visited[i] is False:
                              visited[i] = True
                              queue.append(i)
              def have_edge_from(self,s,d):
                  for i in self.elements[s]:
                      if i == d:
                          return True
                  return False
          g = graph()
          g.add_edge(0,1)
          g.add_edge(0,2)
          g.add_edge(1,2)
          g.add_edge(2,0)
          g.add_edge(2,3)
          g.add_edge(3,3)
          g.print_bfs(0)
          print(g.have_edge_from(2,3))
          
   import time 
          start = time.clock()
          class Queue:
              def __init__(self,max_size):

                  self.__max_size=max_size
                  self.__elements=[None]*self.__max_size
                  self.__rear=-1
                  self.__front=0

              def is_full(self):
                  if(self.__rear==self.__max_size-1):
                          return True
                  return False

              def is_empty(self):
                  if(self.__front>self.__rear):
                      return True
                  return False

              def enqueue(self,data):
                  if(self.is_full()):
                      print("Queue is full!!!")
                  else:
                      self.__rear+=1
                      self.__elements[self.__rear]=data

              def dequeue(self):
                  if(self.is_empty()):
                      print("Queue is empty!!!")
                  else:
                      data=self.__elements[self.__front]
                      self.__front+=1
                      return data

              def display(self):
                  for index in range(self.__front, self.__rear+1):
                      print(self.__elements[index])


              def get_max_size(self):
                  return self.__max_size

              #You can use the below __str__() to print the elements of the DS object while debugging
              def __str__(self):
                  msg=[]
                  index=self.__front
                  while(index<=self.__rear):
                      msg.append((str)(self.__elements[index]))
                      index+=1
                  msg=" ".join(msg)
                  msg="Queue data(Front to Rear): "+msg
                  return msg
          class Node:
              def __init__(self,key):
                  self.key = key
                  self.right = None
                  self.left = None
          class binary_tree:
              def __init__(self,key):
                  self.root = Node(key)
          def Level_order(root):
              if root is None:
                  print("Empty")
                  return 0
              q1 = Queue(500)
              q1.enqueue(root)
              print(root.key,end=" ")
              while not q1.is_empty():
                  data = q1.dequeue()
                  if data.left is not None:
                      q1.enqueue(data.left)
                      print(data.left.key,end=" ")
                  if data.right is not None:
                      q1.enqueue(data.right)
                      print(data.right.key,end=" ")
          def make_min_bin_tree_from(arr):
              if len(arr) == 0:
                  return None
              queue = []
              root = Node(arr.pop(0))
              queue.append(root)
              while len(arr):
                  node = queue.pop(0)
                  node.left = Node(arr.pop(0))
                  queue.append(node.left)
                  if len(arr):
                      node.right = Node(arr.pop(0))
                      queue.append(node.right)
              return root
          def make_min_bin_tree_recursively(arr):
              return make_tree(arr,0,(len(arr)-1))
          def make_tree(arr,start,end):
              if end<start:
                  return None
              mid = (start+end) // 2
              n = Node(arr[mid])
              n.left = make_tree(arr,start,mid-1)
              n.right = make_tree(arr,mid+1,end)
              return n
          arr= [1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,9]
          Level_order(make_min_bin_tree_from(arr))
          Level_order(make_min_bin_tree_recursively(arr))
          print("\n")
          print(time.clock()-start)
  
  

}


